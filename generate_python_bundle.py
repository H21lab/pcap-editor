import os
import json
import base64
import shutil

def generate_bundle():
    base_dir = os.path.dirname(os.path.abspath(__file__))
    src_python_dir = os.path.join(base_dir, "src", "core", "python")
    templates_dir = os.path.join(base_dir, "public", "Templates")
    output_file = os.path.join(base_dir, "src", "core", "pythonBundle.ts")
    public_python_dir = os.path.join(base_dir, "public", "python")

    bundle = {
        "core": {},
        "handlers": {},
        "core_utils": {},
        "templates": {}
    }

    def read_files(path, target_dict):
        if not os.path.exists(path): return
        for f in os.listdir(path):
            if f.endswith(".py") and f != "__init__.py":
                with open(os.path.join(path, f), "rb") as fh:
                    target_dict[f] = base64.b64encode(fh.read()).decode('utf-8')

    # Core engine and logic go into the BUNDLE for instant availability
    read_files(src_python_dir, bundle["core"])
    read_files(os.path.join(src_python_dir, "handlers"), bundle["handlers"])
    read_files(os.path.join(src_python_dir, "core_utils"), bundle["core_utils"])
    read_files(templates_dir, bundle["templates"])

    # Write the TS bundle (MINIFIED - no indent to save space)
    with open(output_file, "w") as f:
        f.write("// AUTHORITATIVE BUNDLE - GENERATED BY generate_python_bundle.py\n")
        f.write("/* eslint-disable */\n")
        f.write("export const pythonBundle: any = ")
        f.write(json.dumps(bundle)) # No indent to avoid "Invalid string length" in Babel
        f.write(";\n")

    # Sync core Python files to public/python for WASM regression tests
    # This ensures WASM tests use the same code as Linux tests
    os.makedirs(public_python_dir, exist_ok=True)
    handlers_dest = os.path.join(public_python_dir, "handlers")
    os.makedirs(handlers_dest, exist_ok=True)

    # Sync core files
    for f in os.listdir(src_python_dir):
        if f.endswith(".py"):
            shutil.copy2(os.path.join(src_python_dir, f), os.path.join(public_python_dir, f))

    # Sync handlers
    handlers_src = os.path.join(src_python_dir, "handlers")
    if os.path.exists(handlers_src):
        for f in os.listdir(handlers_src):
            if f.endswith(".py"):
                shutil.copy2(os.path.join(handlers_src, f), os.path.join(handlers_dest, f))

    # Sync to public/python for Large Library Dependencies (Pycrate ASN1)
    # This is where pycrate_asn1dir lives, which is too big for the bundle.
    asn1_src = os.path.join(src_python_dir, "pycrate_asn1dir")
    asn1_dest = os.path.join(public_python_dir, "pycrate_asn1dir")

    if os.path.exists(asn1_src):
        os.makedirs(asn1_dest, exist_ok=True)
        py_files = [f for f in os.listdir(asn1_src) if f.endswith(".py")]
        for f in py_files:
            shutil.copy2(os.path.join(asn1_src, f), os.path.join(asn1_dest, f))

        # Update index.json for runtime fetching
        with open(os.path.join(asn1_dest, "index.json"), "w") as f:
            json.dump(py_files, f)

    print(f"Authoritative bundle generated at {output_file}")
    print(f"Core Python files synced to {public_python_dir}")
    print(f"Large libraries synced to {asn1_dest}")

if __name__ == "__main__":
    generate_bundle()